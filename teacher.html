<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <title>Truthseekers Teacher Dashboard</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 20px;
        background: #f5f5f5;
      }
      h1 {
        margin-bottom: 10px;
      }
      #games {
        margin-bottom: 20px;
      }
      .game-card {
        background: #ffffff;
        border-radius: 6px;
        padding: 10px 12px;
        margin-bottom: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .game-meta {
        font-size: 12px;
        color: #555;
      }
      button {
        margin: 2px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
      }
      button.primary {
        background: #1976d2;
        color: white;
        border: none;
        border-radius: 3px;
      }
      button.secondary {
        background: #eeeeee;
        border: 1px solid #cccccc;
        border-radius: 3px;
      }
      button.danger {
        background: #d32f2f;
        color: white;
        border: none;
        border-radius: 3px;
      }
      #debugView {
        margin-top: 20px;
      }
      .section {
        background: #ffffff;
        border-radius: 6px;
        padding: 10px 12px;
        margin-bottom: 16px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .section h2 {
        margin-top: 0;
        font-size: 18px;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 12px;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 4px 6px;
        text-align: left;
      }
      th {
        background: #f0f0f0;
      }
      .badge {
        display: inline-block;
        padding: 1px 6px;
        border-radius: 10px;
        font-size: 10px;
        background: #eee;
      }
      .badge.goodie {
        background: #c8e6c9;
        color: #1b5e20;
      }
      .badge.baddie {
        background: #ffcdd2;
        color: #b71c1c;
      }
      .badge.dead {
        background: #eeeeee;
        color: #757575;
        text-decoration: line-through;
      }
      .badge.done {
        background: #c8e6c9;
        color: #1b5e20;
      }
      .badge.todo {
        background: #eeeeee;
        color: #555;
      }
      .pod-label {
        font-weight: bold;
        margin-top: 4px;
      }
      .small {
        font-size: 11px;
        color: #666;
      }
      #eliminationPopup {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 12px 18px;
        border-radius: 8px;
        font-size: 16px;
        display: none;
        z-index: 9999;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        text-align: center;
      }
      #eliminationPopup.show {
        display: block;
        animation: fadeSlideDown 0.25s ease-out,
          fadeOut 0.4s ease-out 2.6s forwards;
      }
      #eliminationPopup .skull {
        font-size: 32px;
        margin-right: 8px;
        vertical-align: middle;
      }
      #eliminationPopup .message {
        font-weight: 700;
        text-transform: uppercase;
        vertical-align: middle;
      }
      @keyframes fadeSlideDown {
        from {
          opacity: 0;
          transform: translate(-50%, -10px);
        }
        to {
          opacity: 1;
          transform: translate(-50%, 0);
        }
      }
      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: translate(-50%, 0);
        }
        to {
          opacity: 0;
          transform: translate(-50%, -10px);
        }
      }
      #statusBar {
        margin-bottom: 10px;
        font-size: 12px;
        color: #555;
      }
      /* Game-over modal */
      #gameOverModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      #gameOverModal.show {
        display: flex;
      }
      #gameOverModal .panel {
        background: #fff;
        border-radius: 10px;
        width: min(760px, 92vw);
        max-height: 86vh;
        overflow: auto;
        padding: 16px 16px 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      #gameOverModal .panel h2 {
        margin: 0 0 6px;
      }
      #gameOverModal .reason {
        margin: 0 0 12px;
        color: #444;
        font-size: 13px;
      }
      #gameOverModal .baddiesGrid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 8px;
        margin-top: 10px;
      }
      .player-card {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 8px;
        border-radius: 6px;
        background: #f6f6f6;
      }
      .player-card img {
        width: 42px;
        height: 42px;
        border-radius: 0;
        object-fit: contain;
        background: transparent;
      }
      .player-card .names {
        line-height: 1.2;
      }
      .player-card .character-name {
        font-weight: 700;
        font-size: 14px;
      }
      .player-card .real-name {
        font-size: 12px;
        color: #555;
      }
      #gameOverModal .actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <h1>Truthseekers ‚Äì Teacher Dashboard</h1>
    <div id="statusBar">API: <span id="apiUrl"></span></div>
    <div id="eliminationPopup">
      <div
        style="
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
        "
      >
        <span class="skull">‚ò†Ô∏è</span>
        <span class="message">ELIMINATED</span>
      </div>
      <div id="eliminationCards" style="margin-top: 10px"></div>
    </div>

    <div
      id="gameOverModal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="gameOverTitle"
    >
      <div class="panel">
        <h2 id="gameOverTitle">Game Over</h2>
        <div class="reason" id="gameOverReason"></div>
        <div class="small" style="margin-top: 6px; font-weight: 600">
          Baddies were:
        </div>
        <div class="baddiesGrid" id="baddiesGrid"></div>
        <div class="actions">
          <button class="secondary" onclick="closeGameOverModal()">
            Close
          </button>
        </div>
      </div>
    </div>

    <div id="games" class="section">
      <h2>Games</h2>
      <button class="secondary" onclick="createGame()">+ New Game</button>
      <button class="secondary" onclick="loadGames()">Refresh</button>
      <div id="gamesList"></div>
    </div>

    <div id="debugView" class="section" style="display: none">
      <h2>Game Detail</h2>
      <div id="gameInfo"></div>
      <div style="margin-top: 10px">
        <div class="small">Student join link:</div>
        <div id="joinLink" class="small" style="word-break: break-all"></div>
        <div style="margin-top: 6px">
          <div class="small">Scan to join:</div>
          <div id="qrContainer"></div>
        </div>
      </div>
      <div style="margin-top: 8px">
        <button class="secondary" onclick="setPhase('rally')">Rally</button>
        <button class="secondary" onclick="setPhase('interview1')">
          Interview 1
        </button>
        <button class="secondary" onclick="setPhase('interview2')">
          Interview 2
        </button>
        <button class="secondary" onclick="setPhase('feedback')">
          Feedback
        </button>
        <button class="secondary" onclick="setPhase('voting')">Voting</button>
        <button class="secondary" onclick="nextRound()">Next Round</button>
        <button class="secondary" id="toggleRolesBtn" onclick="toggleRoles()">
          Show roles
        </button>
        <button class="secondary" onclick="refreshDebug()">
          Refresh Debug
        </button>
        <button class="danger" onclick="forceLogoutAll()">
          Reset all devices
        </button>
      </div>

      <h3>Players</h3>
      <div id="playersTable"></div>

      <h3>Pods</h3>
      <div id="podsView"></div>

      <h3>Interview Assignments</h3>
      <div id="assignmentsView"></div>

      <h3>Votes</h3>
      <div id="votesView"></div>
    </div>

    <script>
      const API = window.location.origin;
      document.getElementById("apiUrl").textContent = API;

      let currentGameId = null;
      let currentDebugData = null;
      let previousPlayerStatus = {};
      let eliminationTimeoutId = null;
      let showRoles = false;
      let lastSeenFinishedForGame = {};

      async function loadGames() {
        const gamesListDiv = document.getElementById("gamesList");
        gamesListDiv.innerHTML = "Loading games‚Ä¶";

        try {
          const res = await fetch(API + "/games");
          if (!res.ok) {
            gamesListDiv.innerHTML = "Error loading games.";
            return;
          }
          const games = await res.json();
          if (!games.length) {
            gamesListDiv.innerHTML = "<p>No games found. Create one!</p>";
            return;
          }

          gamesListDiv.innerHTML = "";
          games.forEach((game) => {
            const div = document.createElement("div");
            div.className = "game-card";

            const header = document.createElement("div");
            header.className = "game-header";

            const left = document.createElement("div");
            left.innerHTML = `
          <div><strong>Game ${game.id}</strong> ‚Äì Code: <code>${
              game.code
            }</code></div>
          <div class="game-meta">
            Status: ${game.status}
            &nbsp;‚Ä¢&nbsp; Round: ${game.current_round || "-"}
            &nbsp;‚Ä¢&nbsp; Subround: ${game.current_subround || "-"}
          </div>
        `;

            const right = document.createElement("div");
            const debugBtn = document.createElement("button");
            debugBtn.className = "primary";
            debugBtn.textContent = "Open";
            debugBtn.onclick = () => openDebug(game.id);

            const startBtn = document.createElement("button");
            startBtn.className = "secondary";
            startBtn.textContent = "Start Game";
            startBtn.onclick = () => startGame(game.id);

            right.appendChild(debugBtn);
            right.appendChild(startBtn);
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "danger";
            deleteBtn.textContent = "Delete";
            deleteBtn.onclick = async () => {
              if (
                !confirm(
                  `Delete game ${game.id} (${game.code})? This cannot be undone.`
                )
              )
                return;
              try {
                const res = await fetch(API + `/games/${game.id}`, {
                  method: "DELETE",
                });
                if (!res.ok) {
                  const text = await res.text();
                  console.error(text);
                  alert("Could not delete game: " + text);
                  return;
                }
                // If we're viewing this game, hide the debug panel
                if (currentGameId === game.id) {
                  currentGameId = null;
                  currentDebugData = null;
                  document.getElementById("debugView").style.display = "none";
                }
                await loadGames();
              } catch (err) {
                console.error(err);
                alert("Error deleting game (see console).");
              }
            };
            right.appendChild(deleteBtn);

            header.appendChild(left);
            header.appendChild(right);

            div.appendChild(header);
            gamesListDiv.appendChild(div);
          });
        } catch (err) {
          console.error(err);
          gamesListDiv.innerHTML = "Error loading games (see console).";
        }
      }

      async function createGame() {
        try {
          const res = await fetch(API + "/games", { method: "POST" });
          if (!res.ok) {
            alert("Could not create game");
            return;
          }
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error creating game (see console).");
        }
      }

      async function startGame(gameId) {
        if (
          !confirm(
            "Start game " +
              gameId +
              "? This will assign roles and start round 1."
          )
        )
          return;
        try {
          const res = await fetch(API + `/games/${gameId}/start`, {
            method: "POST",
          });
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not start game: " + text);
            return;
          }
          await loadGames();
          await openDebug(gameId);
        } catch (err) {
          console.error(err);
          alert("Error starting game (see console).");
        }
      }

      async function openDebug(gameId) {
        currentGameId = gameId;
        document.getElementById("debugView").style.display = "block";
        await refreshDebug();
      }

      async function refreshDebug() {
        if (!currentGameId) return;
        try {
          const res = await fetch(API + `/games/${currentGameId}/debug`);
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not load debug info: " + text);
            return;
          }
          const data = await res.json();
          currentDebugData = data;
          renderDebug(data);
        } catch (err) {
          console.error(err);
          alert("Error loading debug info (see console).");
        }
      }

      async function setSubround(subround) {
        if (!currentGameId) return;
        try {
          const res = await fetch(API + `/games/${currentGameId}/subround`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ subround }),
          });
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not set subround: " + text);
            return;
          }
          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error setting subround (see console).");
        }
      }

      async function setPhase(phase) {
        if (!currentGameId) return;
        try {
          const res = await fetch(API + `/games/${currentGameId}/phase`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ phase }),
          });
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not set phase: " + text);
            return;
          }
          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error setting phase (see console).");
        }
      }

      async function nextRound() {
        if (!currentGameId) return;
        if (!confirm("Create next round for game " + currentGameId + "?"))
          return;

        try {
          const res = await fetch(API + `/games/${currentGameId}/next-round`, {
            method: "POST",
          });
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not create next round: " + text);
            return;
          }
          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error creating next round (see console).");
        }
      }

      async function forceLogoutAll() {
        if (!currentGameId) return;
        if (
          !confirm(
            "Reset ALL devices for this game? This will kick everyone to the join screen and clear saved logins on their iPads within ~3 seconds."
          )
        )
          return;

        try {
          const res = await fetch(
            API + `/games/${currentGameId}/force-logout`,
            {
              method: "POST",
            }
          );
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not reset devices: " + text);
            return;
          }
          const out = await res.json();
          alert(
            `Reset signal sent (seq: ${out.force_logout_seq}). Players will reset on their next poll.`
          );
          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error resetting devices (see console). ");
        }
      }

      async function markGhost(playerId, playerLabel) {
        if (!currentGameId) return;
        const label = playerLabel || "player " + playerId;
        if (!confirm("Mark " + label + " as a ghost?")) return;

        try {
          const res = await fetch(
            API + `/games/${currentGameId}/players/${playerId}/ghost`,
            {
              method: "POST",
            }
          );
          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not mark player as ghost: " + text);
            return;
          }
          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error marking player as ghost (see console).");
        }
      }
      async function renamePlayer(playerId, currentName) {
        if (!currentGameId) return;

        const existing = (currentName || "").toString();
        const next = prompt("New name for this player:", existing);
        if (next === null) return; // cancelled

        const cleaned = next.trim();
        if (!cleaned) {
          alert("Name cannot be empty.");
          return;
        }
        if (cleaned.length > 40) {
          alert("Name too long (max 40 characters).");
          return;
        }

        try {
          const res = await fetch(
            API + `/games/${currentGameId}/players/${playerId}/rename`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ display_name: cleaned }),
            }
          );

          if (!res.ok) {
            const text = await res.text();
            console.error(text);
            alert("Could not rename player: " + text);
            return;
          }

          await refreshDebug();
          await loadGames();
        } catch (err) {
          console.error(err);
          alert("Error renaming player (see console).");
        }
      }

      function toggleRoles() {
        showRoles = !showRoles;
        const btn = document.getElementById("toggleRolesBtn");
        if (btn) {
          btn.textContent = showRoles ? "Hide roles" : "Show roles";
        }
        if (currentDebugData) {
          renderDebug(currentDebugData);
        }
      }

      function showEliminationPopup(players) {
        const popup = document.getElementById("eliminationPopup");
        const cardsEl = document.getElementById("eliminationCards");
        if (!popup || !cardsEl) return;

        const list = Array.isArray(players) ? players : [];
        cardsEl.innerHTML = "";

        function ghostifyFilename(filename) {
          if (!filename) return filename;
          if (filename.startsWith("ghost_")) return filename;
          return `ghost_${filename}`;
        }

        list.forEach((p) => {
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.alignItems = "center";
          wrap.style.justifyContent = "center";
          wrap.style.gap = "10px";
          wrap.style.marginTop = "6px";

          const img = document.createElement("img");
          img.style.width = "40px";
          img.style.height = "40px";
          img.style.objectFit = "contain";
          img.style.borderRadius = "0";

          if (p && p.character_avatar_file) {
            const file = ghostifyFilename(p.character_avatar_file);
            img.src = `/assets/icons/${file}`;
          }
          img.alt = p.character_name || "avatar";

          const txt = document.createElement("div");
          txt.style.fontWeight = "700";
          txt.style.textTransform = "uppercase";
          txt.style.fontSize = "14px";
          const charName = p.character_name || "";
          const realName = p.display_name || "";
          txt.textContent = charName ? `${charName} (${realName})` : realName;

          wrap.appendChild(img);
          wrap.appendChild(txt);
          cardsEl.appendChild(wrap);
        });

        // restart animation
        popup.classList.remove("show");
        void popup.offsetWidth;
        popup.classList.add("show");

        if (eliminationTimeoutId) {
          clearTimeout(eliminationTimeoutId);
        }
        eliminationTimeoutId = setTimeout(() => {
          popup.classList.remove("show");
        }, 3000);
      }

      function formatDebugName(displayName, characterName) {
        if (characterName) {
          return `${displayName} (${characterName})`;
        }
        return displayName;
      }

      function closeGameOverModal() {
        const modal = document.getElementById("gameOverModal");
        if (modal) modal.classList.remove("show");
      }

      function createSmallPlayerCard(player) {
        const card = document.createElement("div");
        card.className = "player-card";

        const img = document.createElement("img");

        function ghostifyFilename(filename) {
          if (!filename) return filename;
          if (filename.startsWith("ghost_")) return filename;
          return `ghost_${filename}`;
        }

        // Prefer avatar file if present; use ghost version if eliminated
        if (player && player.character_avatar_file) {
          const file =
            player.is_alive === false
              ? ghostifyFilename(player.character_avatar_file)
              : player.character_avatar_file;

          img.src = `/assets/icons/${file}`;
        }

        img.alt = player.character_name || "avatar";

        const names = document.createElement("div");
        names.className = "names";

        const characterName = document.createElement("div");
        characterName.className = "character-name";
        characterName.textContent = player.character_name || "";

        const realName = document.createElement("div");
        realName.className = "real-name";
        realName.textContent = `(${player.display_name || ""})`;

        names.appendChild(characterName);
        names.appendChild(realName);

        card.appendChild(img);
        card.appendChild(names);

        return card;
      }

      function maybeShowGameOverModal(data) {
        if (!data || !data.game) return;
        const g = data.game;
        const gameId = g.id;
        const finished = g.status === "finished";

        if (!finished) {
          lastSeenFinishedForGame[gameId] = false;
          return;
        }

        // Only show once per game per page load
        if (lastSeenFinishedForGame[gameId] === true) return;
        lastSeenFinishedForGame[gameId] = true;

        const winning = g.winning_side;
        const title = document.getElementById("gameOverTitle");
        const reason = document.getElementById("gameOverReason");

        if (title) {
          if (winning === "baddies")
            title.textContent = "Game Over ‚Äî Baddies win";
          else if (winning === "goodies")
            title.textContent = "Game Over ‚Äî Goodies win";
          else title.textContent = "Game Over";
        }

        if (reason) {
          if (winning === "baddies") {
            reason.textContent =
              "Baddies win: more baddies alive than goodies alive.";
          } else if (winning === "goodies") {
            reason.textContent = "Goodies win: all baddies eliminated.";
          } else {
            reason.textContent = "The game has ended.";
          }
        }

        // Build baddies list from debug players (safe because game is finished)
        const baddies = (data.players || []).filter((p) => p.role === "baddie");
        const grid = document.getElementById("baddiesGrid");
        if (grid) {
          grid.innerHTML = "";
          if (!baddies.length) {
            grid.innerHTML = '<div class="small">No baddies found.</div>';
          } else {
            baddies.forEach((p) => {
              grid.appendChild(createSmallPlayerCard(p));
            });
          }
        }

        const modal = document.getElementById("gameOverModal");
        if (modal) modal.classList.add("show");
      }

      function renderDebug(data) {
        // Detect newly eliminated players (alive -> out) and show popup
        const prev = previousPlayerStatus || {};
        const newlyEliminated = [];
        if (data.players && Array.isArray(data.players)) {
          data.players.forEach((p) => {
            const prevEntry = prev[p.id];
            if (prevEntry && prevEntry.is_alive && !p.is_alive) {
              newlyEliminated.push(p);
            }
          });
          // update stored status
          previousPlayerStatus = {};
          data.players.forEach((p) => {
            previousPlayerStatus[p.id] = { is_alive: p.is_alive };
          });
        }
        if (newlyEliminated.length > 0) {
          showEliminationPopup(newlyEliminated);
        }
        maybeShowGameOverModal(data);
        // Build lookup maps for player labels
        const playersById = {};
        const playerLabelById = {};
        if (data.players && Array.isArray(data.players)) {
          data.players.forEach((p) => {
            playersById[p.id] = p;
            playerLabelById[p.id] = formatDebugName(
              p.display_name,
              p.character_name
            );
          });
        }

        // Game info
        const gameInfoDiv = document.getElementById("gameInfo");
        const g = data.game;
        const roundText = g.current_round || "-";
        const subroundText = g.current_subround || "-";
        const phaseText = data.phase || data.game.phase || g.phase || "-";
        gameInfoDiv.innerHTML = `
      <div><strong>Game ${g.id}</strong> ‚Äì Code: <code>${g.code}</code></div>
      <div class="small">
        Status: ${g.status} &nbsp;‚Ä¢&nbsp;
        Phase: ${phaseText} &nbsp;‚Ä¢&nbsp;
        Round: ${roundText} &nbsp;‚Ä¢&nbsp;
        Subround: ${subroundText}
      </div>
    `;

        // Student join link + QR code (prefills code in frontend)
        const joinLinkEl = document.getElementById("joinLink");
        const qrContainer = document.getElementById("qrContainer");
        if (joinLinkEl && qrContainer && g && g.code) {
          const joinUrl =
            window.location.origin +
            "/frontend.html?code=" +
            encodeURIComponent(g.code);
          joinLinkEl.textContent = joinUrl;

          // Rebuild QR each refresh to avoid duplicates
          qrContainer.innerHTML = "";
          if (window.QRCode) {
            new QRCode(qrContainer, {
              text: joinUrl,
              width: 140,
              height: 140,
            });
          } else {
            qrContainer.textContent = "QR library not loaded.";
          }
        }

        // Players table
        const playersDiv = document.getElementById("playersTable");
        if (!data.players || !data.players.length) {
          playersDiv.innerHTML = "<p>No players.</p>";
        } else {
          let html =
            "<table><thead><tr><th>ID</th><th>Name</th><th>Role</th><th>Alive</th><th>Pod</th><th>Interview 1 saved</th><th>Interview 2 saved</th><th>Voted</th><th>Subround 1 Target</th><th>Subround 2 Target</th><th>Actions</th></tr></thead><tbody>";

          // Build quick lookup for pods and assignments
          const podByPlayerId = {};
          (data.pods || []).forEach((pod) => {
            pod.members.forEach((m) => {
              podByPlayerId[m.id] = pod.label;
            });
          });

          const assignmentsByPlayer = {};
          (data.assignments || []).forEach((a) => {
            const key = a.interviewer_player_id;
            if (!assignmentsByPlayer[key]) assignmentsByPlayer[key] = {};
            assignmentsByPlayer[key][a.subround] = a.interviewee_name;
          });

          data.players.forEach((p) => {
            const podLabel = podByPlayerId[p.id] || "";
            const a = assignmentsByPlayer[p.id] || {};
            const t1 = a[1] || "";
            const t2 = a[2] || "";

            let roleBadge = '<span class="badge">hidden</span>';
            if (showRoles) {
              if (p.role === "goodie") {
                roleBadge = '<span class="badge goodie">goodie</span>';
              } else if (p.role === "baddie") {
                roleBadge = '<span class="badge baddie">baddie</span>';
              } else {
                roleBadge = '<span class="badge">unknown</span>';
              }
            }

            let aliveBadge = p.is_alive
              ? '<span class="badge">alive</span>'
              : '<span class="badge dead">out</span>';

            const fullName = playerLabelById[p.id] || p.display_name;

            let actionHtml = "";

            // Rename is always available
            actionHtml += `<button class="secondary" onclick='renamePlayer(${
              p.id
            }, ${JSON.stringify(p.display_name || "")})'>Rename</button>`;

            if (p.is_alive) {
              const confirmLabel = fullName;
              actionHtml += ` <button class="danger" onclick='markGhost(${
                p.id
              }, ${JSON.stringify(confirmLabel)})'>Ghost üëª</button>`;
            }

            const interview1Done = !!p.has_saved_interview_subround_1;
            const interview2Done = !!p.has_saved_interview_subround_2;
            const votedDone = !!p.has_voted || !!p.vote_target_id;

            const interview1Badge = interview1Done
              ? '<span class="badge done">yes</span>'
              : '<span class="badge todo">no</span>';
            const interview2Badge = interview2Done
              ? '<span class="badge done">yes</span>'
              : '<span class="badge todo">no</span>';
            const votedBadge = votedDone
              ? '<span class="badge done">yes</span>'
              : '<span class="badge todo">no</span>';

            html += `<tr>
          <td>${p.id}</td>
          <td>${fullName}</td>
          <td>${roleBadge}</td>
          <td>${aliveBadge}</td>
          <td>${podLabel}</td>
          <td>${interview1Badge}</td>
          <td>${interview2Badge}</td>
          <td>${votedBadge}</td>
          <td>${t1}</td>
          <td>${t2}</td>
          <td>${actionHtml}</td>
        </tr>`;
          });

          html += "</tbody></table>";
          playersDiv.innerHTML = html;
        }

        // Pods view
        const podsDiv = document.getElementById("podsView");
        if (!data.pods || !data.pods.length) {
          podsDiv.innerHTML = "<p>No pods for this round.</p>";
        } else {
          let html = "";
          data.pods.forEach((pod) => {
            html += `<div class="pod-label">${pod.label}</div>`;
            if (!pod.members || !pod.members.length) {
              html += '<div class="small">No members.</div>';
              return;
            }
            html += '<div class="small">Members: ';
            html += pod.members
              .map((m) => {
                const baseLabel = playerLabelById[m.id] || m.display_name;
                let label = baseLabel;
                if (showRoles && m.role === "baddie") label += " (baddie)";
                if (!m.is_alive) label += " [out]";
                return label;
              })
              .join(", ");
            html += "</div>";
          });
          podsDiv.innerHTML = html;
        }

        // Assignments view
        const assignDiv = document.getElementById("assignmentsView");
        if (!data.assignments || !data.assignments.length) {
          assignDiv.innerHTML = "<p>No interview assignments.</p>";
        } else {
          let html =
            "<table><thead><tr><th>Subround</th><th>Interviewer</th><th>Interviewee</th></tr></thead><tbody>";
          data.assignments.forEach((a) => {
            html += `<tr>
          <td>${a.subround}</td>
          <td>${a.interviewer_name}</td>
          <td>${a.interviewee_name}</td>
        </tr>`;
          });
          html += "</tbody></table>";
          assignDiv.innerHTML = html;
        }

        // Votes view
        const votesDiv = document.getElementById("votesView");
        if (!data.votes || !data.votes.length) {
          votesDiv.innerHTML = "<p>No votes yet.</p>";
        } else {
          // Build a reverse lookup by display name as a fallback when debug votes lack target_player_id
          const playerByDisplayName = {};
          (data.players || []).forEach((p) => {
            if (p.display_name) playerByDisplayName[p.display_name] = p;
          });

          function voteTargetLabel(v) {
            // Prefer explicit id if present
            const tid = v.target_player_id || v.target_id || null;
            if (tid && playersById[tid]) {
              return { player: playersById[tid], label: playerLabelById[tid] };
            }

            // Fallback: try to match by display name
            const maybe = v.target_name && playerByDisplayName[v.target_name];
            if (maybe) {
              return {
                player: maybe,
                label: playerLabelById[maybe.id] || maybe.display_name,
              };
            }

            // Last resort
            return { player: null, label: v.target_name || "" };
          }

          let vhtml =
            "<table><thead><tr><th>Target</th><th>Votes</th></tr></thead><tbody>";

          data.votes.forEach((v) => {
            const info = voteTargetLabel(v);
            let targetCell = info.label;

            if (info.player && info.player.character_avatar_file) {
              // Use ghost avatar if eliminated
              const file =
                info.player.is_alive === false
                  ? info.player.character_avatar_file.startsWith("ghost_")
                    ? info.player.character_avatar_file
                    : `ghost_${info.player.character_avatar_file}`
                  : info.player.character_avatar_file;

              targetCell = `
                <div style="display:flex; align-items:center; gap:10px;">
                  <img src="/assets/icons/${file}" alt="avatar" style="width:32px; height:32px; object-fit:contain; border-radius:0;" />
                  <div>${info.label}</div>
                </div>
              `;
            }

            vhtml += `<tr>
          <td>${targetCell}</td>
          <td>${v.vote_count}</td>
        </tr>`;
          });

          vhtml += "</tbody></table>";
          votesDiv.innerHTML = vhtml;
        }
      }

      // initial load
      loadGames();
    </script>
  </body>
</html>
